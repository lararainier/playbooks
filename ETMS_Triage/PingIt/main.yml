#
# Pingit - Find all devices on site and ping each one to see if it's up or down
#
---
- hosts: all
  gather_facts: false
  vars:
     ansible_network_os: ios
     outfile: "{{ lookup('env', 'VCATS_INV_WS') | default('.', true) }}/output.dat"
     debugfile: "{{ lookup('env', 'VCATS_INV_WS') | default('.', true) }}/stdout.log"
     errorfile: "{{ lookup('env', 'VCATS_INV_WS') | default('.', true) }}/errors.log"

  tasks:
   - set_fact:
       VCATS_INV_WS: "{{ lookup('env', 'VCATS_INV_WS') }}"
       VCATS_DEVICE_ATTRS_BASE_URL : "{{ lookup('env', 'VCATS_DEVICE_ATTRS_BASE_URL') }}"
       DNSshortname: "{{ DNSEntityName | regex_search('^(.*?)-.*-.*$', '\\1') | first }}"
       DNSlocation: "{{ DNSEntityName | regex_search('^.*-(.*?)-.*$', '\\1') | first }}"
       shortnameExceptions: "['wbacntrl', 'wbansp1', 'wbansp2', 'walgreen', 'walgpilot', 'wbasec', 'wbasp1', 'wbasp2', 'wbasp3']"
       noPingList: "['null', '127.0.0.1', '1.1.1.1']"
       extPingDeviceList: "['Router', 'Firewall Appliance', 'Routing VM']"
     run_once: true
     delegate_to: localhost

   - name: Create debugfile
     lineinfile:
       path: "{{ debugfile }}"
       create: yes
       line: |
         Initiating pingit for {{ DNSEntityName }} with shortname {{ DNSshortname }}
         Retrieving list of entities on site from {{ VCATS_DEVICE_ATTRS_BASE_URL }}inventory-search?invlvl=OPS&pageSize=50&shortName={{ DNSshortname }}&dnsEntityName=-{{ DNSlocation }}-
     delegate_to: localhost
     run_once: true

   # To do - Implement paging to make sure we retrieve all results for large sites
   # To do - Filter out devices that are not under management - how??
   - name: Retrieve location entities from API
     uri:
       url: "{{ VCATS_DEVICE_ATTRS_BASE_URL }}inventory-search?invlvl=OPS&pageSize=50&shortName={{ DNSshortname }}&dnsEntityName=-{{ DNSlocation }}-"
       method: GET
       return_content: yes
     register: cinfo_entities
     delegate_to: localhost
     when: "DNSshortname not in shortnameExceptions"

   - name: Create list of entities to ping
     set_fact:
       entities: "{{ cinfo_entities.json.devices }}"
     when: "DNSshortname not in shortnameExceptions"

   # To do - Implement paging to make sure we retrieve all results for large sites
   - include: shortnameExceptions.yml
     when: "DNSshortname in shortnameExceptions"

   - name: Create list of entities to ping, but skip modems
     set_fact:
       entity: "{{ item.device | combine({'networkDomain' : item.networkDomain}) }}"
     with_items: "{{ entities }}"
     register: entityList

   - name: Remove entities without mgmtIPAddress
     set_fact:
       liveEntities: "{{ entityList.results | map(attribute='ansible_facts.entity') | selectattr('mgmtIPAddress', 'defined') | list }}"

   - name: Add entities to debugfile
     lineinfile:
       path: "{{ debugfile }}"
       line: |
         List of entities to ping for {{ DNSEntityName }}

         {{ liveEntities | to_nice_json}}

     delegate_to: localhost

   # To do - Find a way to ping duplicate IP addresses only once
   - name: Ping entities
     ansible.utils.cli_parse:
       command: "ping {% if item.deviceType in extPingDeviceList %}-c 5 -W 2 -i 0.5{% else %}-c 2 -W 2{% endif %} {{ item.mgmtIPAddress }}"
       parser:
         name: ansible.netcommon.native
         template_path: "templates/rehl_ping.yml"
     register: ping_output
     delegate_to: localhost
     ignore_errors: true
     loop: "{{ liveEntities }}"
     when: item.mgmtIPAddress not in noPingList and item.deviceType != "Modem"

   - name: Add entities to debugfile
     lineinfile:
       path: "{{ debugfile }}"
       line: |
         Ping results for entities related to {{ DNSEntityName }}

         {{ ping_output | to_nice_json}}

     delegate_to: localhost

   - name: Calculate summary results
     set_fact:
       totalPassed: "{{ ping_output.results | selectattr('parsed', 'defined') | list | count }}"
       totalSkipped: "{{ ping_output.results | selectattr('skipped', 'defined') | selectattr('skipped', 'sameas', true) | list | count }}"
       totalFailed: "{{ ping_output.results | selectattr('failed', 'defined') | selectattr('failed', 'sameas', true) | list | count }}"
       totalDevices: "{{ liveEntities | list | count }}"
       failedDevices: "{{ ping_output.results | selectattr('failed', 'defined') | selectattr('failed', 'sameas', true) | map(attribute='item') | map(attribute='dnsEntityName') | list }}"
       deviceTypes: "{{ ping_output.results | selectattr('item', 'defined') | map(attribute='item') | selectattr('deviceType','defined') | map(attribute='deviceType') | list | unique }}"

   - name: Create output.dat file
     lineinfile:
       path: "{{ outfile }}"
       create: yes
       line: "parsedevices=true"
     delegate_to: localhost
     run_once: true

   - name: Print line to output.dat file
     lineinfile:
       path: "{{ outfile }}"
       line: |
         {{ domain }}#{{ DNSEntityName }}#Success#Pingit {{ DNSEntityName }}
         DNS ENTITY NAME                IP               (DOMAIN) ENTITY TYPE          STATUS
         ----------------------------------------------------------------------------------------------------------
         {% for item in ping_output.results %}
         {{ item.item.dnsEntityName }}{%
         if item.item.dnsEntityName|length < 31 %}{% for i in range(31 - item.item.dnsEntityName|length) %} {% endfor %}{% else %} {% endif
         %}{{ item.item.mgmtIPAddress | default('') }}{%
         if item.item.mgmtIPAddress|default('')|length < 16 %}{% for i in range(16 - item.item.mgmtIPAddress|default('')|length) %} {% endfor %}{% endif
         %} ({{ item.item.networkDomain | regex_replace('^d(\d+).*$', "\1") }})  {{ item.item.deviceType | default('') }}  {%
         if item.item.deviceType|default('')|length < 22 %}{% for i in range(22 - item.item.deviceType|default('')|length) %} {% endfor %}{% endif %}{%
         if item.skipped is defined and item.skipped == true %}SKIPPED{% elif item.failed is defined and item.failed == true %}-FAILED-{% else %}-ALIVE-{% endif %}{%
         if item.item.deviceType in extPingDeviceList and item.parsed is defined %}    {% for ping in item.parsed %}{{ item.parsed[ping].rtt }}{% endfor %} ms{% endif %} 
         {% endfor %}
         ----------------------------------------------------------------------------------------------------------
           Total Pass: {{ totalPassed }}  Total Failed: {{ totalFailed }}  Total Skipped: {{ totalSkipped }}

           Ping: Total alive {{ totalPassed }}/{{ totalDevices }} - {%
         for devType in deviceTypes %}{{ devType }} {{ ping_output.results | selectattr('failed', 'defined') | selectattr('failed', 'sameas', false) | map(attribute='item') | list | json_query('[?deviceType==`'~ devType ~ '`]') | count }}/{{ ping_output.results | map(attribute='item') | list | json_query('[?deviceType==`' ~ devType ~ '`]') | count }}{{ " - " if not loop.last else "" }}{%
          endfor %} 
           Ping failed: {{ failedDevices | join(', ') }} 

     delegate_to: localhost
